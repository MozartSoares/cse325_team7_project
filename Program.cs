using cse325_team7_project.Components;
using cse325_team7_project.Api.Options;
using cse325_team7_project.Api.Services;
using cse325_team7_project.Api.Services.Interfaces;
using cse325_team7_project.Domain.Models;
using cse325_team7_project.Api.Security;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Http;
using Microsoft.IdentityModel.Tokens;
using MongoDB.Driver;
using System.Text;
using cse325_team7_project.Domain.Enums;

var builder = WebApplication.CreateBuilder(args);

// User secrets
builder.Configuration
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true)
    .AddEnvironmentVariables()
    .AddUserSecrets<Program>(optional: true);

// --- UI layer -----------------------------------------------------------------
// Register the Razor component stack generated by the Blazor template. Even though
// this backend now exposes REST controllers, we keep the interactive server-side UI
// so the existing front-end continues to function.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

// Add HttpClient for Blazor components to call our own API
builder.Services.AddHttpClient();

// --- API layer ----------------------------------------------------------------
// Enable controllers and insert our ObjectId binder at the front of the provider
// pipeline so every action parameter of type ObjectId benefits from automatic
// parsing and consistent 400 responses when malformed ids are supplied.
builder.Services.AddControllers(options =>
{
    options.ModelBinderProviders.Insert(0, new cse325_team7_project.Api.Binders.ObjectIdModelBinderProvider());
});

// --- AuthN/Z ------------------------------------------------------------------
// Configure JWT bearer authentication and basic role-based authorization.

//this part reads the settings from the appsettings.json file
var jwtSection = builder.Configuration.GetSection("Jwt");
var jwtIssuer = jwtSection["Issuer"] ?? "local";
var jwtAudience = jwtSection["Audience"] ?? jwtIssuer;
var jwtKey = jwtSection["Key"] ?? "CHANGE_ME_DEV_ONLY_SUPER_SECRET_KEY_32+CHARS";

builder.Services.Configure<JwtOptions>(jwtSection);

builder.Services

    //sets jwt as auth method for the api
    .AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = true;
        options.SaveToken = true;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidIssuer = jwtIssuer,
            ValidateAudience = true,
            ValidAudience = jwtAudience,
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey)),
            ValidateLifetime = true,
            ClockSkew = TimeSpan.FromMinutes(1),
            RoleClaimType = "role"
        };

        // Return JSON payloads for 401/403 to match existing error middleware shape.
        options.Events = new JwtBearerEvents
        {
            //when is not authenticated
            OnChallenge = ctx =>
            {
                ctx.HandleResponse();
                if (!ctx.Response.HasStarted)
                {
                    ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;
                    ctx.Response.ContentType = "application/json";
                    return ctx.Response.WriteAsync("{\"message\":\"Unauthorized\"}");
                }
                return Task.CompletedTask;
            },
            //when is not authorized (do not have permission)
            OnForbidden = ctx =>
            {
                ctx.Response.StatusCode = StatusCodes.Status403Forbidden;
                ctx.Response.ContentType = "application/json";
                return ctx.Response.WriteAsync("{\"message\":\"Forbidden\"}");
            }
        };
    });

builder.Services.AddAuthorizationBuilder()
    .AddPolicy("AdminOnly", policy => policy.RequireAssertion(ctx => ctx.User.IsAdmin()))
    .AddPolicy("SelfOrAdmin", policy => policy.RequireAssertion(ctx =>
    {
        var http = (ctx.Resource as Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext)?.HttpContext ?? ctx.Resource as HttpContext;
        var routeId = http?.Request?.RouteValues?["id"]?.ToString();
        if (!MongoDB.Bson.ObjectId.TryParse(routeId, out var targetId)) return false;
        return ctx.User.IsSelfOrAdmin(targetId);
    }));

// --- Data layer ---------------------------------------------------------------
// Resolve MongoDB dependencies via DI. These registrations make the actual
// connection configuration explicit and keep services simple to test/mock.
var mongoConfig = builder.Configuration.GetSection("Mongo");
builder.Services.AddSingleton<IMongoClient>(sp =>
{
    var cs = mongoConfig["ConnectionString"] ?? "mongodb://localhost:27017";
    return new MongoClient(cs);
});
builder.Services.AddSingleton(sp =>
{
    var dbName = mongoConfig["Database"] ?? "moviehub";
    return sp.GetRequiredService<IMongoClient>().GetDatabase(dbName);
});
builder.Services.AddSingleton<IMongoCollection<Movie>>(sp => sp.GetRequiredService<IMongoDatabase>().GetCollection<Movie>("movies"));
builder.Services.AddSingleton<IMongoCollection<User>>(sp => sp.GetRequiredService<IMongoDatabase>().GetCollection<User>("users"));
builder.Services.AddSingleton<IMongoCollection<MoviesList>>(sp => sp.GetRequiredService<IMongoDatabase>().GetCollection<MoviesList>("lists"));

// --- Domain services ----------------------------------------------------------
// Register our CRUD services at scoped lifetime so each HTTP request gets its own
// instance while still leveraging the shared Mongo collections above.
builder.Services.AddScoped<IMovieService, MovieService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IMoviesListService, MoviesListService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IPasswordHasher<User>, PasswordHasher<User>>();

var app = builder.Build();

// --- HTTP pipeline ------------------------------------------------------------
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();

// Catch HttpException and other failures early so controllers can stay lean.
app.UseMiddleware<cse325_team7_project.Api.Middleware.ErrorHandlingMiddleware>();

app.UseAuthentication();
app.UseAuthorization();

app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.MapControllers();

// --- Database bootstrap (indexes) -------------------------------------------
using (var scope = app.Services.CreateScope())
{
    try
    {
        var users = scope.ServiceProvider.GetRequiredService<IMongoCollection<User>>();
        var collation = new MongoDB.Driver.Collation("en", strength: MongoDB.Driver.CollationStrength.Secondary);
        var usernameIndex = new CreateIndexModel<User>(
            Builders<User>.IndexKeys.Ascending(u => u.Username),
            new CreateIndexOptions { Unique = true, Name = "uq_users_username", Collation = collation }
        );
        var emailIndex = new CreateIndexModel<User>(
            Builders<User>.IndexKeys.Ascending(u => u.Email),
            new CreateIndexOptions { Unique = true, Name = "uq_users_email", Collation = collation }
        );

        users.Indexes.CreateMany(new[] { usernameIndex, emailIndex });
    }
    catch (Exception)
    {
        // Index creation is best-effort at startup.
    }
}

app.Run();
